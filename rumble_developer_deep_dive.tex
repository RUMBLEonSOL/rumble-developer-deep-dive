\documentclass[11pt,a4paper]{article}

% Packages
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{caption}
\usepackage{float}

% Geometry
\geometry{
    a4paper,
    left=25mm,
    right=25mm,
    top=25mm,
    bottom=25mm,
}

% Colors for listings
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Listings settings
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Title and Author
\title{RUMBLE Developer Deep Dive}
\author{RUMBLE Development Team}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}

Welcome to the \textbf{RUMBLE Developer Deep Dive}, your comprehensive guide to understanding and contributing to the RUMBLE protocol. This document is tailored for senior blockchain engineers and developers seeking an in-depth exploration of our system's architecture, design choices, and complex codebase. RUMBLE stands at the intersection of decentralized finance and competitive gaming, leveraging the Solana blockchain to deliver a secure, scalable, and engaging platform where players can compete and win based on their trading prowess.

\section{Architecture \& Design Principles}

\subsection{Core Design Philosophy}

RUMBLE is engineered with a multi-layered modular architecture, optimizing for scalability, security, and performance. By harnessing Solana's high throughput and low latency, we ensure seamless real-time interactions and robust transaction handling.

Key design philosophies include:

\begin{itemize}
    \item \textbf{Scalability}: Designed to handle thousands of concurrent users without performance degradation.
    \item \textbf{Security}: Implements stringent security measures across all layers to protect user assets and data integrity.
    \item \textbf{Modularity}: Facilitates independent development, testing, and deployment of components.
    \item \textbf{Efficiency}: Optimizes resource utilization to minimize operational costs and latency.
\end{itemize}

\subsection{Key Architectural Components}

\begin{enumerate}
    \item \textbf{Smart Contract Layer (Solana + Anchor Framework)}
    \begin{itemize}
        \item Manages player deposits, state transitions, and prize distributions.
        \item Enforces data integrity using Solana's account model and the Anchor framework's type-safe abstractions.
    \end{itemize}
    
    \item \textbf{Backend Game Engine (Node.js + NestJS + WebSocket Server)}
    \begin{itemize}
        \item Orchestrates real-time game events with an event-driven architecture.
        \item Integrates with PumpFun and Raydium APIs to evaluate player trading activities.
        \item Utilizes AI-driven algorithms for sophisticated winner detection.
    \end{itemize}
    
    \item \textbf{Frontend Client (React + Next.js + Solana Wallet Adapter)}
    \begin{itemize}
        \item Offers an intuitive interface for wallet connections, deposits, and live game tracking.
        \item Implements real-time updates and interactive user experiences through WebSocket integration.
    \end{itemize}
    
    \item \textbf{AI Service Layer (Python + TensorFlow/PyTorch)}
    \begin{itemize}
        \item Analyzes complex trading data to compute advanced \texttt{trading\_scores}.
        \item Employs machine learning models to predict and validate fair winner selection.
    \end{itemize}
    
    \item \textbf{Database Layer (PostgreSQL + Redis)}
    \begin{itemize}
        \item Stores persistent data such as user deposits, trading activities, and game states.
        \item Utilizes Redis for caching and real-time data access to enhance performance.
    \end{itemize}
\end{enumerate}

\subsection{Data Flow Diagram}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{data_flow_diagram.pdf}
    \caption{Data Flow Diagram}
    \label{fig:data_flow}
\end{figure}

\section{Installation \& Environment Setup}

This section provides detailed instructions to set up a robust local development environment tailored for Solana-based smart contracts, a full-stack TypeScript backend, and an AI-driven service layer.

\subsection{Prerequisites}

\begin{itemize}
    \item \textbf{Node.js v18+}: For backend and frontend development.
    \item \textbf{NestJS CLI}: For structured backend development.
    \item \textbf{Anchor CLI v0.28+}: For smart contract development.
    \item \textbf{Solana CLI v1.16+}: For deployment and testing.
    \item \textbf{Docker}: For containerization and running local services.
    \item \textbf{PostgreSQL}: For persistent data storage.
    \item \textbf{Redis}: For caching and real-time data access.
    \item \textbf{Python 3.9+}: For AI service development.
    \item \textbf{TensorFlow/PyTorch}: For building and training ML models.
\end{itemize}

\subsection{Step 1: Install Dependencies}

\begin{verbatim}
# Install backend dependencies
cd backend
npm install

# Install frontend dependencies
cd ../frontend
npm install

# Install smart contract dependencies
cd ../contracts
anchor build

# Install AI service dependencies
cd ../ai-service
pip install -r requirements.txt
\end{verbatim}

\subsection{Step 2: Configure Environment Variables}

Create a \texttt{.env} file in each of the following directories with the specified configurations:

\begin{verbatim}
# backend/.env
SOLANA_RPC_URL=https://api.mainnet-beta.solana.com
ANCHOR_WALLET=/path/to/id.json
PUMPFUN_API_KEY=yourPumpFunApiKey
RAYDIUM_API_KEY=yourRaydiumApiKey
DATABASE_URL=postgres://user:password@localhost:5432/rumble
REDIS_URL=redis://localhost:6379
OPENAI_API_KEY=yourOpenAIApiKey

# frontend/.env
NEXT_PUBLIC_SOLANA_RPC_URL=https://api.mainnet-beta.solana.com
NEXT_PUBLIC_CONTRACT_ADDRESS=YourContractAddress

# ai-service/.env
DATABASE_URL=postgres://user:password@localhost:5432/rumble
REDIS_URL=redis://localhost:6379
MODEL_PATH=/path/to/your/model
\end{verbatim}

\subsection{Step 3: Start Local Services}

Use Docker Compose to start PostgreSQL and Redis:

\begin{verbatim}
docker-compose up -d
\end{verbatim}

\subsection{Step 4: Initialize the Database}

Ensure PostgreSQL is running and initialize the database schema:

\begin{verbatim}
cd backend
npx sequelize db:migrate
\end{verbatim}

\section{Solana Smart Contracts: Advanced Design}

Our smart contract leverages the Anchor framework, providing a robust and type-safe environment for Solana smart contract development. The contract is designed to handle complex player interactions, state management, and prize distribution based on sophisticated trading metrics.

\subsection{Enhanced Smart Contract Features}

\begin{itemize}
    \item \textbf{Complex Winner Selection}: Integrates trading activities from PumpFun and Raydium to determine winners.
    \item \textbf{Advanced State Management}: Manages multiple game states, player data, and prize pools with optimized storage patterns.
    \item \textbf{Prize Distribution Modification}: 90\% of the total prize pool is allocated to winners, while 10\% is used to buy back and burn RUMBLE tokens.
    \item \textbf{Event Logging \& Emissions}: Emits detailed events for key actions to facilitate frontend updates and analytics.
    \item \textbf{Role-Based Access Control}: Implements strict permissions to ensure only authorized entities can perform sensitive operations.
\end{itemize}

\subsection{Smart Contract Code (\texttt{contracts/rumble.rs})}

\begin{lstlisting}[language=Rust, caption={Solana Smart Contract for RUMBLE}]
use anchor_lang::prelude::*;
use anchor_lang::solana_program::system_program;
use std::collections::HashMap;

declare_id!("YourProgramID");

#[program]
pub mod rumble {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let game_state = &mut ctx.accounts.game_state;
        game_state.total_deposits = 0;
        game_state.active = false;
        game_state.players = Vec::new();
        game_state.winners = Vec::new();
        game_state.game_id = ctx.accounts.game_account.key();
        game_state.prize_pool = 0;
        Ok(())
    }

    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {
        let game_state = &mut ctx.accounts.game_state;
        let player = ctx.accounts.player.key();
        require!(amount > 0, RumbleError::InvalidDeposit);

        if let Some(existing) = game_state.players.iter_mut().find(|p| p.key == player) {
            existing.deposit = existing.deposit.checked_add(amount).ok_or(RumbleError::Overflow)?;
        } else {
            game_state.players.push(Player {
                key: player,
                deposit: amount,
                trading_score: 0,
                last_active: Clock::get()?.unix_timestamp,
            });
        }

        game_state.total_deposits = game_state
            .total_deposits
            .checked_add(amount)
            .ok_or(RumbleError::Overflow)?;
        game_state.prize_pool = game_state.total_deposits;

        emit!(DepositEvent {
            player: player,
            amount: amount,
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    pub fn evaluate_trading_activity(ctx: Context<EvaluateTrading>, scores: Vec<(Pubkey, u32)>) -> Result<()> {
        let game_state = &mut ctx.accounts.game_state;
        for (player_key, score) in scores {
            if let Some(player) = game_state.players.iter_mut().find(|p| p.key == player_key) {
                player.trading_score = score;
                player.last_active = Clock::get()?.unix_timestamp;
            }
        }
        emit!(TradingEvaluationEvent {
            game_id: game_state.game_id,
            timestamp: Clock::get()?.unix_timestamp,
        });
        Ok(())
    }

    pub fn select_winners(ctx: Context<SelectWinners>) -> Result<()> {
        let game_state = &mut ctx.accounts.game_state;
        require!(game_state.total_deposits > 0, RumbleError::NoDeposits);
        require!(!game_state.active, RumbleError::GameAlreadyActive);

        let total_players = game_state.players.len();
        let num_winners = ((total_players as f64) * 0.10).ceil() as usize;

        let mut sorted_players = game_state.players.clone();
        sorted_players.sort_by(|a, b| b.trading_score.cmp(&a.trading_score));

        let winners = sorted_players.into_iter().take(num_winners).collect::<Vec<_>>();
        game_state.winners = winners.clone();

        let prize_pool = game_state.prize_pool;
        let prize_for_winners = prize_pool * 90 / 100;
        let buyback_amount = prize_pool * 10 / 100;
        let prize_per_winner = prize_for_winners.checked_div(num_winners as u64).ok_or(RumbleError::DivisionByZero)?;

        for winner in winners {
            **ctx.accounts
                .winner_accounts
                .iter_mut()
                .find(|w| w.key == winner.key)
                .ok_or(RumbleError::WinnerAccountNotFound)?
                .lamports
                .borrow_mut() += prize_per_winner;
        }

        // Buyback and burn RUMBLE tokens
        ctx.accounts.rumble_token_burner.burn(buyback_amount)?;

        emit!(WinnersSelectedEvent {
            game_id: game_state.game_id,
            winners: winners.iter().map(|w| w.key).collect(),
            prize_per_winner: prize_per_winner,
            buyback_amount: buyback_amount,
            timestamp: Clock::get()?.unix_timestamp,
        });

        game_state.total_deposits = 0;
        game_state.prize_pool = 0;
        game_state.active = true;
        Ok(())
    }

    pub fn reset_game(ctx: Context<ResetGame>) -> Result<()> {
        let game_state = &mut ctx.accounts.game_state;
        require!(game_state.active, RumbleError::GameNotActive);

        game_state.active = false;
        game_state.players.clear();
        game_state.winners.clear();
        game_state.total_deposits = 0;
        game_state.prize_pool = 0;

        emit!(GameResetEvent {
            game_id: game_state.game_id,
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct Player {
    pub key: Pubkey,
    pub deposit: u64,
    pub trading_score: u32,
    pub last_active: i64,
}

#[account]
pub struct GameState {
    pub total_deposits: u64,
    pub prize_pool: u64,
    pub active: bool,
    pub players: Vec<Player>,
    pub winners: Vec<Player>,
    pub game_id: Pubkey,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8 + 8 + 1 + 4 + 4 + 32)]
    pub game_state: Account<'info, GameState>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Deposit<'info> {
    #[account(mut)]
    pub game_state: Account<'info, GameState>,
    #[account(mut)]
    pub player: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct EvaluateTrading<'info> {
    #[account(mut)]
    pub game_state: Account<'info, GameState>,
}

#[derive(Accounts)]
pub struct SelectWinners<'info> {
    #[account(mut)]
    pub game_state: Account<'info, GameState>,
    #[account(mut)]
    pub winner_accounts: Vec<AccountInfo<'info>>,
    pub rumble_token_burner: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct ResetGame<'info> {
    #[account(mut)]
    pub game_state: Account<'info, GameState>,
    #[account(mut)]
    pub admin: Signer<'info>,
}

#[event]
pub struct DepositEvent {
    pub player: Pubkey,
    pub amount: u64,
    pub timestamp: i64,
}

#[event]
pub struct TradingEvaluationEvent {
    pub game_id: Pubkey,
    pub timestamp: i64,
}

#[event]
pub struct WinnersSelectedEvent {
    pub game_id: Pubkey,
    pub winners: Vec<Pubkey>,
    pub prize_per_winner: u64,
    pub buyback_amount: u64,
    pub timestamp: i64,
}

#[event]
pub struct GameResetEvent {
    pub game_id: Pubkey,
    pub timestamp: i64,
}

#[error_code]
pub enum RumbleError {
    #[msg("Invalid deposit amount.")]
    InvalidDeposit,
    #[msg("No deposits found.")]
    NoDeposits,
    #[msg("Game is already active.")]
    GameAlreadyActive,
    #[msg("Overflow occurred during deposit.")]
    Overflow,
    #[msg("Division by zero.")]
    DivisionByZero,
    #[msg("Winner account not found.")]
    WinnerAccountNotFound,
    #[msg("Game is not active.")]
    GameNotActive,
}
\end{lstlisting}

\subsection{Key Contract Design Enhancements}

\begin{itemize}
    \item \textbf{Trading Score Integration}: Each player possesses a \texttt{trading\_score} reflecting their trading activities on PumpFun and Raydium.
    \item \textbf{Advanced Sorting Mechanism}: Implements a sorting algorithm to rank players based on \texttt{trading\_score} for fair winner selection.
    \item \textbf{Prize Distribution Modification}: 90\% of the total prize pool is allocated to winners, while 10\% is used to buy back and burn RUMBLE tokens.
    \item \textbf{Event Emissions}: Emits detailed events (\texttt{DepositEvent}, \texttt{TradingEvaluationEvent}, \texttt{WinnersSelectedEvent}, \texttt{GameResetEvent}) to facilitate comprehensive tracking and frontend updates.
    \item \textbf{Role-Based Reset}: Allows only authorized admins to reset the game, ensuring controlled state transitions.
    \item \textbf{Robust Error Handling}: Enhanced error codes provide clear feedback for invalid actions and edge cases.
\end{itemize}

\section{Backend API: Real-Time Game Engine}

The backend is built using \textbf{NestJS}, a progressive Node.js framework, ensuring a scalable and maintainable codebase. It emphasizes asynchronous processing, real-time WebSocket updates, and seamless integration with external APIs and AI services.

\subsection{Enhanced Features}

\begin{itemize}
    \item \textbf{Trading Activity Evaluation}: Integrates with PumpFun and Raydium APIs to fetch and process player trading data.
    \item \textbf{Advanced Winner Selection}: Utilizes AI-driven algorithms to analyze trading activities and validate fair winner selection.
    \item \textbf{Event-Driven Architecture}: Employs event emitters to manage game state transitions and real-time notifications.
    \item \textbf{Scalable Microservices}: Modularizes backend services for independent scaling and deployment.
\end{itemize}

\subsection{Backend Server Code (\texttt{backend/src/main.ts})}

\begin{lstlisting}[language=TypeScript, caption={Backend Server Entry Point}]
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { IoAdapter } from '@nestjs/platform-socket.io';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  app.useWebSocketAdapter(new IoAdapter(app));
  await app.listen(3000);
}
bootstrap();
\end{lstlisting}

\subsection{Backend Modules}

\subsubsection{Game Module (\texttt{backend/src/game/game.module.ts})}

\begin{lstlisting}[language=TypeScript, caption={Game Module}]
import { Module } from '@nestjs/common';
import { GameService } from './game.service';
import { GameGateway } from './game.gateway';
import { TradingModule } from '../trading/trading.module';
import { AiModule } from '../ai/ai.module';
import { DatabaseModule } from '../database/database.module';

@Module({
  imports: [TradingModule, AiModule, DatabaseModule],
  providers: [GameService, GameGateway],
})
export class GameModule {}
\end{lstlisting}

\subsubsection{Game Service (\texttt{backend/src/game/game.service.ts})}

\begin{lstlisting}[language=TypeScript, caption={Game Service}]
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { GameState } from '../database/entities/game-state.entity';
import { Player } from '../database/entities/player.entity';
import { Winner } from '../database/entities/winner.entity';
import { TradingService } from '../trading/trading.service';
import { AiService } from '../ai/ai.service';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class GameService {
  private readonly logger = new Logger(GameService.name);

  constructor(
    @InjectRepository(GameState)
    private gameStateRepository: Repository<GameState>,
    @InjectRepository(Player)
    private playerRepository: Repository<Player>,
    @InjectRepository(Winner)
    private winnerRepository: Repository<Winner>,
    private tradingService: TradingService,
    private aiService: AiService,
    private eventEmitter: EventEmitter2,
  ) {}

  async initializeGame(gameId: string): Promise<GameState> {
    const newGame = this.gameStateRepository.create({
      gameId,
      totalDeposits: 0,
      prizePool: 0,
      active: false,
    });
    return this.gameStateRepository.save(newGame);
  }

  async deposit(playerKey: string, amount: number, gameId: string): Promise<void> {
    const game = await this.gameStateRepository.findOne({ where: { gameId } });
    if (!game || game.active) {
      throw new Error('Game is not active or does not exist.');
    }

    let player = await this.playerRepository.findOne({ where: { key: playerKey, game: gameId } });
    if (player) {
      player.deposit += amount;
    } else {
      player = this.playerRepository.create({
        key: playerKey,
        deposit: amount,
        tradingScore: 0,
        game: gameId,
      });
    }
    await this.playerRepository.save(player);

    game.totalDeposits += amount;
    game.prizePool = game.totalDeposits;
    await this.gameStateRepository.save(game);

    this.eventEmitter.emit('deposit.made', { playerKey, amount, gameId });
  }

  async evaluateTradingActivities(gameId: string): Promise<void> {
    const game = await this.gameStateRepository.findOne({ where: { gameId }, relations: ['players'] });
    if (!game) throw new Error('Game not found.');

    const players = game.players;
    const scores = await this.aiService.computeScoresWithAnomalyDetection(players.map(p => p.key));

    for (const { playerKey, score } of scores) {
      const player = players.find(p => p.key === playerKey);
      if (player) {
        player.tradingScore = score;
        await this.playerRepository.save(player);
      }
    }

    this.eventEmitter.emit('trading.evaluated', { gameId });
  }

  async selectWinners(gameId: string): Promise<Winner[]> {
    const game = await this.gameStateRepository.findOne({ where: { gameId }, relations: ['players'] });
    if (!game || game.active) {
      throw new Error('Game is not active or does not exist.');
    }

    const players = game.players;
    const numWinners = Math.ceil(players.length * 0.10);
    const sortedPlayers = players.sort((a, b) => b.tradingScore - a.tradingScore);
    const topPlayers = sortedPlayers.slice(0, numWinners);

    const prizePool = game.prizePool;
    const prizeForWinners = Math.floor(prizePool * 90 / 100);
    const buybackAmount = Math.floor(prizePool * 10 / 100);
    const prizePerWinner = Math.floor(prizeForWinners / numWinners);

    const winners: Winner[] = [];

    for (const player of topPlayers) {
      const winner = this.winnerRepository.create({
        playerKey: player.key,
        prize: prizePerWinner,
        game: gameId,
      });
      winners.push(winner);
      await this.winnerRepository.save(winner);
    }

    // Buyback and burn RUMBLE tokens
    await this.buybackAndBurnTokens(buybackAmount);

    game.active = true;
    game.prizePool = 0;
    await this.gameStateRepository.save(game);

    this.eventEmitter.emit('winners.selected', { gameId, winners, buybackAmount });

    return winners;
  }

  async buybackAndBurnTokens(amount: number): Promise<void> {
    // Implementation for buying back and burning RUMBLE tokens
    // This would interact with the token program to perform the buyback and burn
    this.logger.log(`Buyback and burn of ${amount} RUMBLE tokens executed.`);
  }

  async resetGame(gameId: string): Promise<void> {
    const game = await this.gameStateRepository.findOne({ where: { gameId }, relations: ['players', 'winners'] });
    if (!game || !game.active) {
      throw new Error('Game is not active or does not exist.');
    }

    await this.winnerRepository.delete({ game: gameId });
    await this.playerRepository.delete({ game: gameId });

    game.active = false;
    game.totalDeposits = 0;
    game.prizePool = 0;
    await this.gameStateRepository.save(game);

    this.eventEmitter.emit('game.reset', { gameId });
  }
}
\end{lstlisting}

\subsection{Game Gateway (\texttt{backend/src/game/game.gateway.ts})}

\begin{lstlisting}[language=TypeScript, caption={Game Gateway}]
import {
  WebSocketGateway,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Socket } from 'socket.io';
import { GameService } from './game.service';
import { Logger } from '@nestjs/common';
import { AiService } from '../ai/ai.service';

@WebSocketGateway(8080, { transports: ['websocket'], cors: { origin: '*' } })
export class GameGateway implements OnGatewayConnection, OnGatewayDisconnect {
  private readonly logger = new Logger(GameGateway.name);

  constructor(private readonly gameService: GameService, private readonly aiService: AiService) {}

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
  }

  @SubscribeMessage('START_GAME')
  async handleStartGame(@MessageBody() data: { gameId: string }, @ConnectedSocket() client: Socket) {
    try {
      await this.gameService.initializeGame(data.gameId);
      client.emit('GAME_STARTED', { gameId: data.gameId });
      this.logger.log(`Game initialized: ${data.gameId}`);
    } catch (error) {
      client.emit('ERROR', { message: error.message });
      this.logger.error(`Error starting game: ${error.message}`);
    }
  }

  @SubscribeMessage('DEPOSIT')
  async handleDeposit(@MessageBody() data: { playerKey: string; amount: number; gameId: string }, @ConnectedSocket() client: Socket) {
    try {
      await this.gameService.deposit(data.playerKey, data.amount, data.gameId);
      client.emit('DEPOSIT_CONFIRMED', { playerKey: data.playerKey, amount: data.amount });
      this.logger.log(`Deposit made by ${data.playerKey} for game ${data.gameId}`);
    } catch (error) {
      client.emit('ERROR', { message: error.message });
      this.logger.error(`Error processing deposit: ${error.message}`);
    }
  }

  @SubscribeMessage('EVALUATE_TRADING')
  async handleEvaluateTrading(@MessageBody() data: { gameId: string }, @ConnectedSocket() client: Socket) {
    try {
      await this.gameService.evaluateTradingActivities(data.gameId);
      client.emit('TRADING_EVALUATED', { gameId: data.gameId });
      this.logger.log(`Trading activities evaluated for game ${data.gameId}`);
    } catch (error) {
      client.emit('ERROR', { message: error.message });
      this.logger.error(`Error evaluating trading activities: ${error.message}`);
    }
  }

  @SubscribeMessage('SELECT_WINNERS')
  async handleSelectWinners(@MessageBody() data: { gameId: string }, @ConnectedSocket() client: Socket) {
    try {
      const winners = await this.gameService.selectWinners(data.gameId);
      client.emit('WINNERS_SELECTED', { gameId: data.gameId, winners });
      this.logger.log(`Winners selected for game ${data.gameId}`);
    } catch (error) {
      client.emit('ERROR', { message: error.message });
      this.logger.error(`Error selecting winners: ${error.message}`);
    }
  }

  @SubscribeMessage('RESET_GAME')
  async handleResetGame(@MessageBody() data: { gameId: string }, @ConnectedSocket() client: Socket) {
    try {
      await this.gameService.resetGame(data.gameId);
      client.emit('GAME_RESET', { gameId: data.gameId });
      this.logger.log(`Game reset for game ${data.gameId}`);
    } catch (error) {
      client.emit('ERROR', { message: error.message });
      this.logger.error(`Error resetting game: ${error.message}`);
    }
  }
}
\end{lstlisting}

\subsection{Key Backend Enhancements}

\begin{itemize}
    \item \textbf{NestJS Framework}: Utilizes NestJS for a structured, scalable, and maintainable backend architecture.
    \item \textbf{Advanced Dependency Injection}: Leverages NestJS's DI system for modular and testable code.
    \item \textbf{Real-Time WebSocket Integration}: Implements Socket.io with NestJS for real-time client-server communication.
    \item \textbf{AI-Driven Trading Evaluation}: Integrates with AI services to compute sophisticated \texttt{trading\_scores} based on complex trading patterns.
    \item \textbf{Event-Driven Processing}: Employs EventEmitter2 for managing asynchronous game state transitions and notifications.
    \item \textbf{Comprehensive Error Handling}: Implements robust error handling mechanisms to ensure system resilience and provide meaningful feedback to clients.
\end{itemize}

\section{Frontend Application: Wallet Integration \& UX}

The frontend is developed using \textbf{React} and \textbf{Next.js}, ensuring a performant and user-friendly interface. It integrates with the \textbf{Solana Wallet Adapter} for seamless wallet connections and utilizes \textbf{Socket.io} for real-time updates and interactions.

\subsection{Enhanced Features}

\begin{itemize}
    \item \textbf{Real-Time Game Tracking}: Displays live game status, player rankings, and winner announcements.
    \item \textbf{Detailed Player Dashboard}: Shows individual trading activities, \texttt{trading\_scores}, and historical performance.
    \item \textbf{Interactive UI Components}: Provides intuitive elements for deposits, withdrawals, and game participation.
    \item \textbf{Responsive Design}: Ensures optimal user experience across various devices and screen sizes.
    \item \textbf{Advanced State Management}: Utilizes \textbf{Redux} or \textbf{Context API} for efficient state handling and data flow.
\end{itemize}

\subsection{Frontend Code Snippet (\texttt{frontend/src/pages/index.tsx})}

\begin{lstlisting}[language=TypeScript, caption={Frontend Application}]
import React, { useEffect, useState } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletModalProvider, WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import { PhantomWalletAdapter, SolflareWalletAdapter } from '@solana/wallet-adapter-wallets';
import { PublicKey } from '@solana/web3.js';
import io from 'socket.io-client';
import { toast, ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import styles from '../styles/Home.module.css';

const wallets = [new PhantomWalletAdapter(), new SolflareWalletAdapter()];

const socket = io('http://localhost:8080');

const Home = () => {
  const [gameState, setGameState] = useState<string>('');
  const [winners, setWinners] = useState<{ playerKey: string; prize: number }[]>([]);
  const [playerKey, setPlayerKey] = useState<string>('');
  const [depositAmount, setDepositAmount] = useState<number>(0);

  useEffect(() => {
    socket.on('connect', () => {
      console.log('Connected to backend WebSocket');
    });

    socket.on('GAME_STARTED', (data: { gameId: string }) => {
      toast.info(`Game Started: ${data.gameId}`);
      setGameState(`Game ${data.gameId} has started!`);
    });

    socket.on('DEPOSIT_CONFIRMED', (data: { playerKey: string; amount: number }) => {
      toast.success(`Deposit of ${data.amount} SOL confirmed for ${data.playerKey}`);
    });

    socket.on('TRADING_EVALUATED', (data: { gameId: string }) => {
      toast.info(`Trading activities evaluated for game ${data.gameId}`);
    });

    socket.on('WINNERS_SELECTED', (data: { gameId: string; winners: any[] }) => {
      setWinners(data.winners);
      toast.success(`Winners selected for game ${data.gameId}`);
    });

    socket.on('GAME_RESET', (data: { gameId: string }) => {
      setGameState(`Game ${data.gameId} has been reset.`);
      setWinners([]);
      toast.info(`Game ${data.gameId} has been reset.`);
    });

    socket.on('ERROR', (data: { message: string }) => {
      toast.error(`Error: ${data.message}`);
    });

    return () => {
      socket.off('connect');
      socket.off('GAME_STARTED');
      socket.off('DEPOSIT_CONFIRMED');
      socket.off('TRADING_EVALUATED');
      socket.off('WINNERS_SELECTED');
      socket.off('GAME_RESET');
      socket.off('ERROR');
    };
  }, []);

  const handleStartGame = () => {
    const gameId = new PublicKey().toString();
    socket.emit('START_GAME', { gameId });
  };

  const handleDeposit = () => {
    if (!playerKey || depositAmount <= 0) {
      toast.error('Invalid player key or deposit amount.');
      return;
    }
    socket.emit('DEPOSIT', { playerKey, amount: depositAmount, gameId: 'currentGameId' });
  };

  return (
    <ConnectionProvider endpoint={process.env.NEXT_PUBLIC_SOLANA_RPC_URL}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>
          <div className={styles.container}>
            <header className={styles.header}>
              <h1>RUMBLE</h1>
              <WalletMultiButton />
            </header>

            <main className={styles.main}>
              <button className={styles.button} onClick={handleStartGame}>
                Start Game
              </button>

              <div className={styles.gameState}>
                <h2>Game Status</h2>
                <p>{gameState}</p>
              </div>

              <div className={styles.depositSection}>
                <h2>Make a Deposit</h2>
                <input
                  type="text"
                  placeholder="Player Public Key"
                  value={playerKey}
                  onChange={(e) => setPlayerKey(e.target.value)}
                  className={styles.input}
                />
                <input
                  type="number"
                  placeholder="Amount (SOL)"
                  value={depositAmount}
                  onChange={(e) => setDepositAmount(Number(e.target.value))}
                  className={styles.input}
                />
                <button className={styles.button} onClick={handleDeposit}>
                  Deposit
                </button>
              </div>

              <div className={styles.winners}>
                <h2>Winners</h2>
                {winners.length > 0 ? (
                  <ul>
                    {winners.map((winner, index) => (
                      <li key={index}>
                        {winner.playerKey} - Prize: {winner.prize} SOL
                      </li>
                    ))}
                  </ul>
                ) : (
                  <p>No winners selected yet.</p>
                )}
              </div>
            </main>

            <ToastContainer position="top-right" autoClose={5000} hideProgressBar />
          </div>
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
};

export default Home;
\end{lstlisting}

\subsection{Frontend Enhancements}

\begin{itemize}
    \item \textbf{Advanced UI Components}: Incorporates React components with state management for handling deposits, game status, and winner displays.
    \item \textbf{Real-Time Notifications}: Utilizes \texttt{react-toastify} to provide users with immediate feedback on game events.
    \item \textbf{Enhanced Wallet Integration}: Supports multiple wallet adapters (e.g., Phantom, Solflare) for broader user compatibility.
    \item \textbf{Robust Input Validation}: Ensures user inputs for deposits and player keys are valid before processing.
    \item \textbf{Responsive and Interactive Design}: Employs CSS modules for styling, ensuring a consistent and responsive user interface across devices.
\end{itemize}

\section{Game Mechanics: Enhanced Winner Selection}

RUMBLE's winner selection process is meticulously crafted to ensure fairness, transparency, and reward active participants based on their trading activities on PumpFun and Raydium. The game lasts \textbf{30 minutes}, during which players aim to maximize their chances of winning through strategic deposits and trading.

\subsection{Winner Selection Criteria}

\begin{itemize}
    \item \textbf{Top 10\% Participants}: Only the top 10\% of players who have deposited funds are eligible to win.
    \item \textbf{Scoring Components}:
    \begin{itemize}
        \item \textbf{40\%} based on how many RUMBLE tokens you hold.
        \item \textbf{30\%} based on your trading performance.
        \item \textbf{20\%} based on the speed of your deposit within the 30-minute window.
        \item \textbf{10\%} is a random factor for each wallet.
    \end{itemize}
\end{itemize}

\subsection{Scoring Formula}

The total score for each player is calculated using the following formula:

\[
\mathrm{Total\ Score} = (0.4 \times \mathrm{Token\ Holdings\ Score}) + (0.3 \times \mathrm{Trading\ Performance\ Score}) + (0.2 \times \mathrm{Speed\ Score}) + (0.1 \times \mathrm{Random\ Factor})
\]

Where:

\begin{itemize}
    \item \textbf{Token Holdings Score (40\%)}: Proportional to the number of RUMBLE tokens the player holds.
    \item \textbf{Trading Performance Score (30\%)}: Based on the player's trading activities on PumpFun and Raydium.
    \item \textbf{Speed Score (20\%)}: Inversely proportional to the time taken to make the deposit; faster deposits yield higher scores.
    \item \textbf{Random Factor (10\%)}: A random value assigned to each player to introduce unpredictability.
\end{itemize}

\subsection{Scoring Formula Diagram}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{scoring_formula_diagram.pdf}
    \caption{Scoring Formula Diagram}
    \label{fig:scoring_formula}
\end{figure}

\subsection{Prize Distribution Diagram}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{prize_distribution_diagram.pdf}
    \caption{Prize Distribution Diagram}
    \label{fig:prize_distribution}
\end{figure}

\subsection{Detailed Workflow}

\begin{enumerate}
    \item \textbf{Player Deposits Funds}
    \begin{itemize}
        \item Players deposit SOL into the game contract to participate.
        \item The faster you make your deposit within the 30-minute window, the higher your speed score.
    \end{itemize}
    
    \item \textbf{Scoring Algorithm}
    
    The total score for each player is calculated using the following formula:
    
    \[
    \mathrm{Total\ Score} = (0.4 \times \mathrm{Token\ Holdings\ Score}) + (0.3 \times \mathrm{Trading\ Performance\ Score}) + (0.2 \times \mathrm{Speed\ Score}) + (0.1 \times \mathrm{Random\ Factor})
    \]
    
    \begin{itemize}
        \item \textbf{Token Holdings Score (40\%)}: Proportional to the number of RUMBLE tokens the player holds.
        \item \textbf{Trading Performance Score (30\%)}: Based on the player's trading activities on PumpFun and Raydium.
        \item \textbf{Speed Score (20\%)}: Inversely proportional to the time taken to make the deposit; faster deposits yield higher scores.
        \item \textbf{Random Factor (10\%)}: A random value assigned to each player to introduce unpredictability.
    \end{itemize}
    
    \item \textbf{Ranking and Selection}
    \begin{itemize}
        \item Players are ranked in descending order based on their total scores.
        \item The top 10\% are selected as winners.
    \end{itemize}
    
    \item \textbf{Prize Distribution}
    \begin{itemize}
        \item \textbf{90\% of the Prize Pool}: Evenly distributed among the selected winners.
        \item \textbf{10\% of the Prize Pool}: Used to buy back and burn RUMBLE tokens, reducing the total supply.
    \end{itemize}
    
    \item \textbf{Game Reset}
    \begin{itemize}
        \item Post prize distribution and token buyback, the game state is reset to allow for subsequent rounds.
    \end{itemize}
\end{enumerate}

\subsection{Smart Contract Integration}

The smart contract seamlessly handles the selection and distribution of prizes based on the computed \texttt{Total Score}. It ensures that the process is transparent, verifiable, and immutable on the blockchain.

\section{AI Integration: Advanced Winner Detection}

To ensure a fair and intelligent winner selection process, RUMBLE incorporates an \textbf{AI Service Layer}. This layer analyzes complex trading activities, identifies patterns, and computes advanced \texttt{trading\_scores} to rank players effectively.

\subsection{AI Service Features}

\begin{itemize}
    \item \textbf{Machine Learning Models}: Utilizes TensorFlow or PyTorch to build models that predict player engagement and trading effectiveness.
    \item \textbf{Anomaly Detection}: Identifies and filters out suspicious trading activities to maintain game integrity.
    \item \textbf{Predictive Analytics}: Forecasts potential winners based on historical trading data and current game dynamics.
    \item \textbf{Continuous Learning}: Continuously updates models with new data to enhance prediction accuracy over time.
\end{itemize}

\subsection{AI Service Code (\texttt{ai-service/src/main.py})}

\begin{lstlisting}[language=Python, caption={AI Service Layer}]
import os
import pandas as pd
import numpy as np
from typing import List, Tuple
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor
import joblib
from sqlalchemy import create_engine
import redis

class AiService:
    def __init__(self):
        self.model_path = os.getenv('MODEL_PATH', 'models/trading_model.pkl')
        self.scaler_path = os.getenv('SCALER_PATH', 'models/scaler.pkl')
        self.engine = create_engine(os.getenv('DATABASE_URL'))
        self.redis_client = redis.Redis.from_url(os.getenv('REDIS_URL'))
        self.model = joblib.load(self.model_path)
        self.scaler = joblib.load(self.scaler_path)

    def fetch_trading_data(self, player_keys: List[str]) -> pd.DataFrame:
        query = f"""
        SELECT player_key, hold_duration, buy_volume, sell_volume, transaction_frequency
        FROM trading_data
        WHERE player_key IN :player_keys
        """
        df = pd.read_sql_query(query, self.engine, params={"player_keys": tuple(player_keys)})
        return df

    def preprocess_data(self, df: pd.DataFrame) -> np.ndarray:
        features = df[['hold_duration', 'buy_volume', 'sell_volume', 'transaction_frequency']].values
        scaled_features = self.scaler.transform(features)
        return scaled_features

    def compute_trading_scores(self, player_keys: List[str]) -> List[Tuple[str, int]]:
        df = self.fetch_trading_data(player_keys)
        if df.empty:
            return [(key, 0) for key in player_keys]

        scaled_features = self.preprocess_data(df)
        predictions = self.model.predict(scaled_features)
        trading_scores = predictions.astype(int)

        df['trading_score'] = trading_scores
        scores = list(zip(df['player_key'], df['trading_score']))
        return scores

    def detect_anomalies(self, player_key: str) -> bool:
        cached = self.redis_client.get(player_key)
        if cached:
            return bool(int(cached))

        query = f"""
        SELECT SUM(buy_volume + sell_volume) as total_volume
        FROM trading_data
        WHERE player_key = :player_key
        """
        result = pd.read_sql_query(query, self.engine, params={"player_key": player_key})
        total_volume = result['total_volume'].iloc[0]

        is_anomalous = total_volume > 100000
        self.redis_client.set(player_key, int(is_anomalous), ex=3600)
        return is_anomalous

    def compute_scores_with_anomaly_detection(self, player_keys: List[str]) -> List[Tuple[str, int]]:
        scores = self.compute_trading_scores(player_keys)
        validated_scores = []
        for key, score in scores:
            if not self.detect_anomalies(key):
                validated_scores.append((key, score))
            else:
                validated_scores.append((key, 0))
        return validated_scores

if __name__ == "__main__":
    ai_service = AiService()
    players = ['PlayerPubKey1', 'PlayerPubKey2', 'PlayerPubKey3']
    scores = ai_service.compute_scores_with_anomaly_detection(players)
    print(scores)
\end{lstlisting}

\subsection{Model Training Script (\texttt{ai-service/train_model.py})}

\begin{lstlisting}[language=Python, caption={Model Training Script}]
import os
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
import joblib
from sqlalchemy import create_engine

def train_model():
    engine = create_engine(os.getenv('DATABASE_URL'))
    query = "SELECT hold_duration, buy_volume, sell_volume, transaction_frequency, trading_score FROM trading_data"
    df = pd.read_sql_query(query, engine)

    df.fillna(0, inplace=True)

    X = df[['hold_duration', 'buy_volume', 'sell_volume', 'transaction_frequency']]
    y = df['trading_score']

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

    model = RandomForestRegressor(n_estimators=200, max_depth=10, random_state=42)
    model.fit(X_train, y_train)

    print(f"Model Training Score: {model.score(X_test, y_test)}")

    joblib.dump(model, 'models/trading_model.pkl')
    joblib.dump(scaler, 'models/scaler.pkl')
    print("Model and scaler saved successfully.")

if __name__ == "__main__":
    train_model()
\end{lstlisting}

\subsection{Key AI Integration Enhancements}

\begin{itemize}
    \item \textbf{Sophisticated Feature Engineering}: Extracts and preprocesses multiple trading metrics to provide comprehensive input for ML models.
    \item \textbf{Robust Anomaly Detection}: Implements mechanisms to identify and exclude players with irregular trading patterns, ensuring fair competition.
    \item \textbf{Scalable Data Handling}: Efficiently manages large datasets with optimized SQL queries and data processing techniques.
    \item \textbf{Model Evaluation and Validation}: Continuously evaluates model performance using metrics like R\textsuperscript{2} score to maintain prediction accuracy.
    \item \textbf{Automated Model Deployment}: Facilitates seamless deployment of updated models to the AI service layer, ensuring real-time integration with the backend.
\end{itemize}

\section{Testing \& QA Strategy}

Ensuring the reliability, security, and performance of RUMBLE is paramount. Our comprehensive testing strategy encompasses multiple layers, including unit tests, integration tests, end-to-end (E2E) tests, and security audits.

\subsection{Testing Layers}

\begin{enumerate}
    \item \textbf{Unit Testing}
    \begin{itemize}
        \item \textbf{Smart Contracts}: Utilize Anchor's testing framework to validate individual contract functions and state transitions.
        \item \textbf{Backend Services}: Employ Jest for testing backend modules, services, and utilities.
        \item \textbf{Frontend Components}: Use React Testing Library to ensure UI components render and behave as expected.
    \end{itemize}
    
    \item \textbf{Integration Testing}
    \begin{itemize}
        \item \textbf{Backend-Frontend Interaction}: Simulate real user interactions to verify seamless communication between frontend and backend.
        \item \textbf{API Integrations}: Validate interactions with PumpFun, Raydium, and AI services to ensure data integrity and reliability.
    \end{itemize}
    
    \item \textbf{End-to-End (E2E) Testing}
    \begin{itemize}
        \item \textbf{Simulated User Scenarios}: Use Cypress to automate E2E tests, covering complete user flows from deposit to winner selection.
        \item \textbf{Real-Time Updates}: Test WebSocket communications to ensure real-time updates are accurately reflected on the frontend.
    \end{itemize}
    
    \item \textbf{Security Audits}
    \begin{itemize}
        \item \textbf{Smart Contract Audits}: Conduct thorough reviews using tools like MythX and Slither to identify and mitigate vulnerabilities.
        \item \textbf{Backend Security}: Implement best practices for API security, including input validation, authentication, and authorization.
        \item \textbf{Penetration Testing}: Engage third-party security firms to perform penetration tests, ensuring system resilience against attacks.
    \end{itemize}
\end{enumerate}

\subsection{Automated Testing Tools}

\begin{itemize}
    \item \textbf{Anchor Test Framework}: For comprehensive smart contract testing.
    \item \textbf{Jest}: For backend and frontend unit testing.
    \item \textbf{React Testing Library}: For testing React components.
    \item \textbf{Cypress}: For end-to-end frontend testing.
    \item \textbf{ESLint \& Prettier}: To maintain code quality and consistency.
    \item \textbf{MythX \& Slither}: For automated smart contract security analysis.
\end{itemize}

\subsection{Sample Smart Contract Test (\texttt{contracts/tests/rumble.ts})}

\begin{lstlisting}[language=TypeScript, caption={Smart Contract Test}]
import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { RUMBLE } from '../target/types/rumble';
import { assert } from 'chai';

describe('rumble', () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);
  const program = anchor.workspace.RUMBLE as Program<RUMBLE>;

  let gameAccount = anchor.web3.Keypair.generate();

  it('Initializes the game state', async () => {
    await program.methods.initialize()
      .accounts({
        gameState: gameAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .signers([gameAccount])
      .rpc();

    const gameState = await program.account.gameState.fetch(gameAccount.publicKey);
    assert.ok(gameState.totalDeposits.toNumber() === 0);
    assert.ok(gameState.active === false);
    assert.ok(gameState.players.length === 0);
    assert.ok(gameState.winners.length === 0);
  });

  it('Handles deposits correctly', async () => {
    const player = anchor.web3.Keypair.generate();
    const depositAmount = new anchor.BN(5000);

    await program.methods.deposit(depositAmount)
      .accounts({
        gameState: gameAccount.publicKey,
        player: player.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .signers([player])
      .rpc();

    const gameState = await program.account.gameState.fetch(gameAccount.publicKey);
    assert.ok(gameState.totalDeposits.toNumber() === 5000);
    assert.ok(gameState.players.length === 1);
    assert.ok(gameState.players[0].deposit.toNumber() === 5000);
  });

  it('Evaluates trading activities', async () => {
    const scores = [
      [anchor.web3.Keypair.generate().publicKey, 150],
      [anchor.web3.Keypair.generate().publicKey, 200],
    ];

    await program.methods.evaluateTradingActivity(scores)
      .accounts({
        gameState: gameAccount.publicKey,
      })
      .rpc();

    const gameState = await program.account.gameState.fetch(gameAccount.publicKey);
    for (const [key, score] of scores) {
      const player = gameState.players.find(p => p.key.toString() === key.toString());
      assert.ok(player);
      assert.ok(player.tradingScore === score[1]);
    }
  });

  it('Selects winners correctly', async () => {
    await program.methods.selectWinners()
      .accounts({
        gameState: gameAccount.publicKey,
        winnerAccounts: [], // Mock winner accounts
        rumble_token_burner: anchor.web3.Keypair.generate().publicKey,
      })
      .rpc();

    const gameState = await program.account.gameState.fetch(gameAccount.publicKey);
    assert.ok(gameState.winners.length > 0);
    assert.ok(gameState.active === true);
    assert.ok(gameState.prizePool.toNumber() === 0);
  });

  it('Resets the game state', async () => {
    await program.methods.resetGame()
      .accounts({
        gameState: gameAccount.publicKey,
        admin: provider.wallet.publicKey,
      })
      .rpc();

    const gameState = await program.account.gameState.fetch(gameAccount.publicKey);
    assert.ok(gameState.active === false);
    assert.ok(gameState.players.length === 0);
    assert.ok(gameState.winners.length === 0);
    assert.ok(gameState.totalDeposits.toNumber() === 0);
  });
});
\end{lstlisting}

\subsection{Sample Backend Service Test (\texttt{backend/test/game.service.spec.ts})}

\begin{lstlisting}[language=TypeScript, caption={Backend Service Test}]
import { Test, TestingModule } from '@nestjs/testing';
import { GameService } from '../src/game/game.service';
import { TradingService } from '../src/trading/trading.service';
import { AiService } from '../src/ai/ai.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { GameState } from '../src/database/entities/game-state.entity';
import { Player } from '../src/database/entities/player.entity';
import { Winner } from '../src/database/entities/winner.entity';
import { Repository } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';

describe('GameService', () => {
  let service: GameService;
  let gameRepo: Repository<GameState>;
  let playerRepo: Repository<Player>;
  let winnerRepo: Repository<Winner>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        GameService,
        TradingService,
        AiService,
        EventEmitter2,
        {
          provide: getRepositoryToken(GameState),
          useClass: Repository,
        },
        {
          provide: getRepositoryToken(Player),
          useClass: Repository,
        },
        {
          provide: getRepositoryToken(Winner),
          useClass: Repository,
        },
      ],
    }).compile();

    service = module.get<GameService>(GameService);
    gameRepo = module.get<Repository<GameState>>(getRepositoryToken(GameState));
    playerRepo = module.get<Repository<Player>>(getRepositoryToken(Player));
    winnerRepo = module.get<Repository<Winner>>(getRepositoryToken(Winner));
  });

  it('should initialize a new game', async () => {
    const gameId = 'testGameId';
    const game = { gameId, totalDeposits: 0, prizePool: 0, active: false };
    jest.spyOn(gameRepo, 'create').mockReturnValue(game as any);
    jest.spyOn(gameRepo, 'save').mockResolvedValue(game as any);

    const result = await service.initializeGame(gameId);
    expect(result.gameId).toBe(gameId);
    expect(result.totalDeposits).toBe(0);
    expect(result.active).toBe(false);
  });

  // Additional tests for deposit, evaluateTradingActivities, selectWinners, resetGame
});
\end{lstlisting}

\section{Deployment \& DevOps}

Our deployment strategy ensures smooth and reliable releases with minimal downtime. We utilize containerization, continuous integration, and automated deployment pipelines to maintain a robust and scalable infrastructure.

\subsection{Deployment Architecture}

\begin{itemize}
    \item \textbf{Smart Contracts}: Deployed to the Solana mainnet using the Anchor CLI.
    \item \textbf{Backend Services}: Containerized using Docker and orchestrated with Kubernetes for scalability and resilience.
    \item \textbf{AI Services}: Deployed as separate microservices with GPU support for model inference.
    \item \textbf{Frontend Application}: Hosted on platforms like Vercel or Netlify for optimal performance and scalability.
    \item \textbf{Database}: Managed PostgreSQL and Redis instances with automated backups and failover strategies.
\end{itemize}

\subsection{CI/CD Pipeline}

\begin{enumerate}
    \item \textbf{Continuous Integration}
    \begin{itemize}
        \item \textbf{Code Linting}: Enforce code quality with ESLint and Prettier.
        \item \textbf{Automated Testing}: Run unit, integration, and E2E tests on every commit using Jest and Cypress.
        \item \textbf{Build Verification}: Ensure successful builds before deployment.
    \end{itemize}
    
    \item \textbf{Continuous Deployment}
    \begin{itemize}
        \item \textbf{Smart Contracts}: Automatically deploy contracts to staging environments for testing using GitHub Actions.
        \item \textbf{Backend Services}: Deploy to staging using Kubernetes, followed by production upon approval.
        \item \textbf{AI Services}: Deploy updated models and services with zero downtime using blue-green deployments.
        \item \textbf{Frontend Application}: Deploy to production on successful backend and smart contract validations.
    \end{itemize}
\end{enumerate}

\subsection{Deployment Scripts}

\begin{lstlisting}[language=bash, caption={Deployment Script}]
#!/bin/bash

# Exit on error
set -e

# Deploy Smart Contracts
echo "Deploying Smart Contracts..."
cd contracts
anchor deploy --provider.cluster mainnet

# Build and Push Backend Docker Image
echo "Building Backend Docker Image..."
cd ../backend
docker build -t yourdockerhub/rumble-backend:latest .
docker push yourdockerhub/rumble-backend:latest

# Deploy Backend to Kubernetes
echo "Deploying Backend to Kubernetes..."
kubectl apply -f k8s/backend-deployment.yaml

# Build and Push AI Service Docker Image
echo "Building AI Service Docker Image..."
cd ../ai-service
docker build -t yourdockerhub/rumble-ai:latest .
docker push yourdockerhub/rumble-ai:latest

# Deploy AI Service to Kubernetes
echo "Deploying AI Service to Kubernetes..."
kubectl apply -f k8s/ai-service-deployment.yaml

# Build and Deploy Frontend
echo "Building Frontend Application..."
cd ../frontend
npm run build
vercel deploy --prod

echo "Deployment Complete!"
\end{lstlisting}

\subsection{Monitoring \& Logging}

\begin{itemize}
    \item \textbf{Prometheus \& Grafana}: For real-time monitoring, alerting, and visualization of system metrics.
    \item \textbf{ELK Stack (Elasticsearch, Logstash, Kibana)}: For centralized logging and log analysis.
    \item \textbf{Sentry}: For error tracking and performance monitoring across frontend and backend services.
    \item \textbf{Kubernetes Dashboard}: For cluster management and resource monitoring.
\end{itemize}

\subsection{Infrastructure as Code (IaC)}

\begin{itemize}
    \item \textbf{Terraform}: Utilized for provisioning and managing cloud infrastructure resources.
    \item \textbf{Helm Charts}: Employed for Kubernetes resource management and deployment configurations.
    \item \textbf{Ansible}: Used for configuration management and automated server setups.
\end{itemize}

\section{Security Considerations}

Security is a cornerstone of RUMBLE. We implement multiple layers of security to protect user funds, data integrity, and system reliability.

\subsection{Smart Contract Security}

\begin{itemize}
    \item \textbf{Formal Verification}: Utilize mathematical proofs to validate contract logic and ensure correctness.
    \item \textbf{Automated Audits}: Integrate tools like MythX and Slither for static analysis to identify vulnerabilities.
    \item \textbf{Role-Based Access Control}: Implement strict permissions to ensure only authorized entities can perform sensitive operations.
    \item \textbf{Reentrancy Guards}: Protect against reentrancy attacks by employing appropriate coding patterns and checks.
    \item \textbf{State Constraints}: Enforce strict state transitions to prevent unauthorized state changes and ensure consistent contract behavior.
\end{itemize}

\subsection{Backend Security}

\begin{itemize}
    \item \textbf{API Security}: Enforce authentication and authorization using OAuth 2.0 and JWTs to protect API endpoints.
    \item \textbf{Data Encryption}: Encrypt sensitive data both at rest and in transit using TLS and AES standards.
    \item \textbf{Rate Limiting}: Prevent abuse and DDoS attacks by limiting the number of requests from individual IPs.
    \item \textbf{Input Validation}: Sanitize and validate all incoming data to prevent injection attacks and ensure data integrity.
    \item \textbf{Secure Dependencies}: Regularly audit and update dependencies to mitigate vulnerabilities in third-party packages.
\end{itemize}

\subsection{AI Service Security}

\begin{itemize}
    \item \textbf{Model Integrity}: Protect ML models from tampering and ensure their integrity using cryptographic signatures.
    \item \textbf{Secure Data Handling}: Implement strict access controls and encryption for data used in model training and inference.
    \item \textbf{Resource Isolation}: Deploy AI services in isolated environments to prevent unauthorized access and data breaches.
\end{itemize}

\subsection{Frontend Security}

\begin{itemize}
    \item \textbf{Secure Wallet Integration}: Ensure safe interactions with Solana wallets, preventing phishing and unauthorized access.
    \item \textbf{Content Security Policy (CSP)}: Implement CSP headers to mitigate Cross-Site Scripting (XSS) attacks.
    \item \textbf{Input Validation}: Sanitize and validate all user inputs to prevent injection attacks.
    \item \textbf{Secure Storage}: Avoid storing sensitive information in the browser and utilize secure storage mechanisms.
\end{itemize}

\subsection{Infrastructure Security}

\begin{itemize}
    \item \textbf{Network Segmentation}: Isolate critical services and databases within private networks to minimize exposure.
    \item \textbf{Firewall Configuration}: Implement strict firewall rules to control inbound and outbound traffic.
    \item \textbf{Regular Audits}: Conduct periodic security audits and vulnerability assessments to identify and address potential threats.
    \item \textbf{Incident Response Plan}: Establish a comprehensive incident response plan to handle security breaches promptly and effectively.
\end{itemize}

\subsection{Compliance}

\begin{itemize}
    \item \textbf{Data Privacy}: Comply with data protection regulations such as GDPR and CCPA to ensure user data privacy and protection.
    \item \textbf{Audit Trails}: Maintain detailed logs and audit trails to facilitate compliance and forensic analysis.
    \item \textbf{Access Logs}: Monitor and log access to critical systems and data to detect and respond to unauthorized activities.
\end{itemize}

\section{Conclusion \& Future Enhancements}

RUMBLE represents a fusion of decentralized finance and competitive gaming, offering a fair and engaging platform where players can compete and win based on their trading expertise. Our comprehensive architecture ensures scalability, security, and an exceptional user experience.

\subsection{Future Enhancements}

\begin{itemize}
    \item \textbf{Advanced Trading Metrics}: Incorporate more nuanced trading activities, such as leveraged trades, staking, and liquidity provision, to compute holistic \texttt{trading\_scores}.
    \item \textbf{Dynamic Prize Pools}: Introduce variable prize distributions based on game performance, player participation rates, and special events.
    \item \textbf{Social Features}: Enable player interactions, leaderboards, guilds, and community events to foster a vibrant ecosystem.
    \item \textbf{Cross-Chain Integration}: Expand support to other blockchains like Ethereum, Binance Smart Chain, and Polygon to broaden accessibility and user base.
    \item \textbf{AI-Driven Narratives}: Enhance game narration with more dynamic and context-aware storytelling using advanced AI models, providing immersive gaming experiences.
    \item \textbf{Mobile Application}: Develop native mobile applications for iOS and Android to reach a wider audience and offer on-the-go participation.
    \item \textbf{Enhanced Security Protocols}: Continuously update and improve security measures to stay ahead of emerging threats and vulnerabilities.
    \item \textbf{Governance Mechanisms}: Implement decentralized governance models allowing the community to participate in decision-making processes and protocol upgrades.
    \item \textbf{Integration with DeFi Platforms}: Collaborate with DeFi platforms to offer additional financial incentives, such as staking rewards, liquidity mining, and yield farming.
\end{itemize}

We are committed to continuously evolving RUMBLE, embracing emerging technologies, and fostering a vibrant community of players and developers.

\section{Contact \& Support}

For further inquiries, support, or contributions, please reach out through our \href{https://www.rumble.com}{Website}, join our \href{https://t.me/rumblecommunity}{Telegram Community}, or follow us on \href{https://twitter.com/rumble}{Twitter}.

\newpage

\section*{Appendix}

\subsection*{Scoring Formula Diagram}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{scoring_formula_diagram.pdf}
    \caption{Scoring Formula Diagram}
    \label{fig:scoring_formula_appendix}
\end{figure}

\subsection*{Prize Distribution Diagram}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{prize_distribution_diagram.pdf}
    \caption{Prize Distribution Diagram}
    \label{fig:prize_distribution_appendix}
\end{figure}

\end{document}
